import a from"node:cluster";import{BehaviorSubject as p,fromEvent as c}from"rxjs";import{filter as k,map as u,switchMap as l,take as h,tap as m}from"rxjs/operators";import{MessageType as i,WorkerMode as s}from"./protocol.js";class v extends Error{constructor(r){super(`Worker exited with unexpected ${r} code`)}}class f{constructor(r){this.options=r}workers=[];workIdCounter=0;get maxSize(){return this.options.concurrency}format(r){this.workers.length<this.options.concurrency&&this.spawnWorker();const e=this.workers[0],o=this.workIdCounter++;if(e?.active&&e.active++,this.sortWorkers(),e?.worker)return e.worker.pipe(l(t=>(t.send({type:i.WorkerFiles,files:r,id:o}),c(t,"message"))),u(([t])=>t),k(t=>t.id===o),h(1),m(()=>{e.active--,this.sortWorkers()}))}sortWorkers(){this.workers.sort((r,e)=>r.active-e.active)}spawnWorker(){const r=a.fork(),e=new p(r);this.workers.unshift({worker:e,active:0}),r.on("exit",(o,t)=>e.error(new v(o??t))),r.on("error",o=>e.error(o)),r.send({mode:this.options.check?s.Assert:this.options.write?s.Write:s.Print,type:i.WorkerInitialization})}}export{v as WorkerExitedError,f as WorkerPool};
